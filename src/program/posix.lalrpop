use program::posix::ast;

grammar;

pub Program: ast::Program = {
    // TODO: We need our own lexer to make this rule work.
    // <p: Program> "\n"+ <c: Commands> => {
    //     let (mut p, c) = (p, c);
    //     p.0.push(box c);
    //     p
    // },
    <p: Program> ";" <j: Job> => {
        let (mut p, j) = (p, j);
        p.0.push(box j);
        p
    },
    Job => ast::Program(vec![box <>]),
}

Compound: ast::Program = {
    <p: Compound> ";" <j: Job> => {
        let (mut p, j) = (p, j);
        p.0.push(box j);
        p
    },
    <p: Compound> ";" => p,
    <p: Job> ";" => ast::Program(vec![box p]),
}

Job: ast::Command = {
    <j: Job> "&" <cs: Commands> => {
        let bg = ast::Command::Background(box j);
        ast::Command::Pair(box bg, box cs)
    },
    <j: Job> "&" => ast::Command::Background(box j),
    Commands => <>,
}

Commands: ast::Command = {
    "(" <p: Program> ")" => {
        ast::Command::Subshell(box p)
    },
    "{" <js: (Job ";")+> "}" => {
        let js = js.into_iter().map(|t| box t.0).collect();
        let p = ast::Program(js);
        ast::Command::Compound(box p)
    },
    // BridgedProgram => <>,
    <cs: Commands> "&&" <p: Pipeline> => {
        ast::Command::And(box cs, box p)
    },
    <cs: Commands> "||" <p: Pipeline> => {
        ast::Command::Or(box cs, box p)
    },
    Pipeline => <>,
}

Pipeline: ast::Command = {
    "!" <ps: PipelineSeq> => ast::Command::Not(box ps),
    <ps: PipelineSeq> => ps,
}

PipelineSeq: ast::Command = {
    <ps: PipelineSeq> "|" "\n"* <c: Command> => {
        ast::Command::Pipeline(box ps, box c)
    },
    <c: Command> => c,
}

pub Command: ast::Command = Word+ => ast::Command::Simple(<>);

// TODO: Custom lexer plus proger rules needed.
pub Word: ast::Word = r"[a-zA-Z0-9-_\.]+" => ast::Word(<>.into());
